
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EMMAttachAccept {
    #[deku(pad_bits_before = "4")] pub eps_attach_result: Type1V<EPSAttachResultV>,
    #[deku(bytes = 1)] pub t_3412: Type3V<GPRSTimer>,
    pub tai_list: Type4LV<()>,
    #[deku(ctx = "NeedsByteSize")] pub esm_container: Type6LVE<Layer3Buffer>,
    #[deku(ctx = "Tag(80)")] pub guti: Type4TLV<EPSID>,
    #[deku(bytes = 5, ctx = "Tag(19)")] pub lai: Type3TV<LAI>,
    #[deku(ctx = "Tag(35)")] pub id: Type4TLV<ID>,
    #[deku(bytes = 1, ctx = "Tag(83)")] pub emm_cause: Type3TV<EMMCauseEMMCause>,
    #[deku(bytes = 1, ctx = "Tag(23)")] pub t_3402: Type3TV<GPRSTimer>,
    #[deku(bytes = 1, ctx = "Tag(89)")] pub t_3423: Type3TV<GPRSTimer>,
    #[deku(ctx = "Tag(74)")] pub equiv_plmn_list: Type4TLV<()>,
    #[deku(ctx = "Tag(52)")] pub emerg_num_list: Type4TLV<()>,
    #[deku(ctx = "Tag(100), NeedsByteSize")] pub eps_net_feat: Type4TLV<EPSNetFeat>,
    #[deku(ctx = "Tag(15)")] pub add_update_res: Type1TV<AddUpdateRes>,
    #[deku(ctx = "Tag(94)")] pub t_3412_ext: Type4TLV<GPRSTimer3>,
    #[deku(ctx = "Tag(106)")] pub t_3324: Type4TLV<GPRSTimer>,
    #[deku(ctx = "Tag(110)")] pub ext_drx_param: Type4TLV<ExtDRXParam>,
    #[deku(ctx = "Tag(14)")] pub sms_serv_stat: Type1TV<SMSServStat>,
    #[deku(ctx = "Tag(13)")] pub non_3_gppnw_prov_pol: Type1TV<Non3GPPNWProvPol>,
    #[deku(ctx = "Tag(107)")] pub t_3448: Type4TLV<GPRSTimer>,
    #[deku(ctx = "Tag(12)")] pub network_pol: Type1TV<NetworkPol>,
    #[deku(ctx = "Tag(108)")] pub t_3447: Type4TLV<GPRSTimer3>,
    #[deku(ctx = "Tag(122)")] pub ext_emerg_num_list: Type6TLVE<ExtEmergNumList>,
    #[deku(ctx = "Tag(124)")] pub cipher_key_data: Type6TLVE<()>,
    #[deku(ctx = "Tag(102), NeedsByteSize")] pub ue_radio_cap_id: Type4TLV<Layer3Buffer>,
    #[deku(ctx = "Tag(11)")] pub ue_radio_cap_id_del_ind: Type1TV<UERadioCapIDDelInd>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct GPRSTimer {
    pub unit: GPRSTimerUnit,
    #[deku(bits = 5)] pub value: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EPSID {

}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct LAI {
    #[deku(count = "3")] pub plmn: Vec<u8>,
    #[deku(bytes = 2, endian = "big")] pub lac: u16,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ID {

}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct EPSNetFeat {
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub cp_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub e_rwo_pdn: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub esr_ps: u8,
    #[deku(cond = "deku::byte_offset < byte_size", default = "EPSNetFeatCSLCS::NoInfo")] pub cs_lcs: EPSNetFeatCSLCS,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub epc_lcs: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub emc_bs: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub ims_vo_ps: u8,
    #[deku(bits = 4, cond = "deku::byte_offset < byte_size")] pub spare: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub epco: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub hc_cp_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub s_1_u_data: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub up_c_io_t: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct AddUpdateRes {
    #[deku(bits = 2)] pub spare: u8,
    pub value: AddUpdateResValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct GPRSTimer3 {
    pub unit: GPRSTimer3Unit,
    #[deku(bits = 5)] pub value: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ExtDRXParam {
    #[deku(bits = 4)] pub ptx: u8,
    #[deku(bits = 4)] pub e_drx: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct SMSServStat {
    #[deku(bits = 1)] pub spare: u8,
    pub value: SMSServStatValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Non3GPPNWProvPol {
    #[deku(bits = 3)] pub spare: u8,
    pub value: Non3GPPNWProvPolValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NetworkPol {
    #[deku(bits = 3)] pub spare: u8,
    pub value: NetworkPolValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ExtEmergNumList {
    #[deku(bits = 7)] pub spare: u8,
    pub eenl_validity: ExtEmergNumListEENLValidity,
    pub eenl: (),
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct UERadioCapIDDelInd {
    #[deku(bits = 1)] pub spare: u8,
    pub del_request: UERadioCapIDDelIndDelRequest,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 4)]
pub enum EPSAttachResultV {
    #[deku(id_pat = "1")] EPSOnly,
    #[deku(id_pat = "2")] CombinedEPSIMSIAttach,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 8)]
pub enum EMMCauseEMMCause {
    #[deku(id_pat = "2")] IMSIUnknownInHSS,
    #[deku(id_pat = "3")] IllegalUE,
    #[deku(id_pat = "5")] IMEINotAccepted,
    #[deku(id_pat = "6")] IllegalME,
    #[deku(id_pat = "7")] EPSServicesNotAllowed,
    #[deku(id_pat = "8")] EPSServicesAndNonEPSServicesNotAllowed,
    #[deku(id_pat = "9")] UEIdentityCannotBeDerivedByTheNetwork,
    #[deku(id_pat = "10")] ImplicitlyDetached,
    #[deku(id_pat = "11")] PLMNNotAllowed,
    #[deku(id_pat = "12")] TrackingAreaNotAllowed,
    #[deku(id_pat = "13")] RoamingNotAllowedInThisTrackingArea,
    #[deku(id_pat = "14")] EPSServicesNotAllowedInThisPLMN,
    #[deku(id_pat = "15")] NoSuitableCellsInTrackingArea,
    #[deku(id_pat = "16")] MSCTemporarilyNotReachable,
    #[deku(id_pat = "17")] NetworkFailure,
    #[deku(id_pat = "18")] CSDomainNotAvailable,
    #[deku(id_pat = "19")] ESMFailure,
    #[deku(id_pat = "20")] MACFailure,
    #[deku(id_pat = "21")] SynchFailure,
    #[deku(id_pat = "22")] Congestion,
    #[deku(id_pat = "23")] UESecurityCapabilitiesMismatch,
    #[deku(id_pat = "24")] SecurityModeRejectedUnspecified,
    #[deku(id_pat = "25")] NotAuthorizedForThisCSG,
    #[deku(id_pat = "26")] NonEPSAuthenticationUnacceptable,
    #[deku(id_pat = "35")] RequestedServiceOptionNotAuthorizedInThisPLMN,
    #[deku(id_pat = "39")] CSServiceTemporarilyNotAvailable,
    #[deku(id_pat = "40")] NoEPSBearerContextActivated,
    #[deku(id_pat = "42")] SevereNetworkFailure,
    #[deku(id_pat = "95")] SemanticallyIncorrectMessage,
    #[deku(id_pat = "96")] InvalidMandatoryInformation,
    #[deku(id_pat = "97")] MessageTypeNonExistentOrNotImplemented,
    #[deku(id_pat = "98")] MessageTypeNotCompatibleWithTheProtocolState,
    #[deku(id_pat = "99")] InformationElementNonExistentOrNotImplemented,
    #[deku(id_pat = "100")] ConditionalIEError,
    #[deku(id_pat = "101")] MessageNotCompatibleWithTheProtocolState,
    #[deku(id_pat = "111")] ProtocolErrorUnspecified,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum UERadioCapIDDelIndDelRequest {
    #[deku(id_pat = "0")] UERadioCapabilityIDDeletionNotRequested,
    #[deku(id_pat = "1")] NetworkAssignedUERadioCapabilityIDsDeletionRequested,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum ExtEmergNumListEENLValidity {
    #[deku(id_pat = "0")] CountryWideList,
    #[deku(id_pat = "1")] PLMNWideList,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum NetworkPolValue {
    #[deku(id_pat = "0")] UnsecuredRedirectionToGERANAllowed,
    #[deku(id_pat = "1")] UnsecuredRedirectionToGERANNotAllowed,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum Non3GPPNWProvPolValue {
    #[deku(id_pat = "0")] UseOfNon3GPPEmergencyNumbersNotPermitted,
    #[deku(id_pat = "1")] UseOfNon3GPPEmergencyNumbersPermitted,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum SMSServStatValue {
    #[deku(id_pat = "0")] SMSServicesNotAvailable,
    #[deku(id_pat = "1")] SMSServicesNotAvailableInThisPLMN,
    #[deku(id_pat = "2")] NetworkFailure,
    #[deku(id_pat = "3")] Congestion,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum GPRSTimer3Unit {
    #[deku(id_pat = "0")] TenMin,
    #[deku(id_pat = "1")] OneHour,
    #[deku(id_pat = "2")] TenHours,
    #[deku(id_pat = "3")] TwoSec,
    #[deku(id_pat = "4")] ThirtySec,
    #[deku(id_pat = "5")] OneMin,
    #[deku(id_pat = "6")] ThreeHundredAndTwentyHours,
    #[deku(id_pat = "7")] TimerDeactivated,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum AddUpdateResValue {
    #[deku(id_pat = "0")] NoAdditionalInformation,
    #[deku(id_pat = "1")] CSFallbackNotPreferred,
    #[deku(id_pat = "2")] SMSOnly,
    #[deku(id_pat = "3")] Reserved,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum EPSNetFeatCSLCS {
    #[deku(id_pat = "0")] NoInfo,
    #[deku(id_pat = "1")] Supported,
    #[deku(id_pat = "2")] NotSupported,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum GPRSTimerUnit {
    #[deku(id_pat = "0")] TwoSec,
    #[deku(id_pat = "1")] OneMin,
    #[deku(id_pat = "2")] SixMin,
    #[deku(id_pat = "7")] TimerDeactivated,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("014906201301846b0100b25201c101051703696d73066d6e63343830066d6363333131046770727309020000000016f6a0df5e02b5b5583327838080211003000010810600000000830600000000000110200148880002713a00a0010400000071000110200148880004fe0000b0010400000259000110200148880004fe0000b0010400000205000310200148880016ff0001e1000d00000000000310200148880017ff0001e4000d00000000001002059400050102ff000413018405500bf6130184fa6aaec191ee7d5302172c3404030019f1640103"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMAttachAccept::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let eps_attach_result = msg.eps_attach_result.inner;
        assert_eq!(eps_attach_result, EPSAttachResultV::EPSOnly);
        let t_3412 = msg.t_3412.inner;
        assert_eq!(t_3412.unit, GPRSTimerUnit::SixMin);
        assert_eq!(t_3412.value, 9);
        let esm_container = msg.esm_container.inner;
        assert_eq!(esm_container, vec![82, 1, 193, 1, 5, 23, 3, 105, 109, 115, 6, 109, 110, 99, 52, 56, 48, 6, 109, 99, 99, 51, 49, 49, 4, 103, 112, 114, 115, 9, 2, 0, 0, 0, 0, 22, 246, 160, 223, 94, 2, 181, 181, 88, 51, 39, 131, 128, 128, 33, 16, 3, 0, 0, 16, 129, 6, 0, 0, 0, 0, 131, 6, 0, 0, 0, 0, 0, 1, 16, 32, 1, 72, 136, 0, 2, 113, 58, 0, 160, 1, 4, 0, 0, 0, 113, 0, 1, 16, 32, 1, 72, 136, 0, 4, 254, 0, 0, 176, 1, 4, 0, 0, 2, 89, 0, 1, 16, 32, 1, 72, 136, 0, 4, 254, 0, 0, 176, 1, 4, 0, 0, 2, 5, 0, 3, 16, 32, 1, 72, 136, 0, 22, 255, 0, 1, 225, 0, 13, 0, 0, 0, 0, 0, 3, 16, 32, 1, 72, 136, 0, 23, 255, 0, 1, 228, 0, 13, 0, 0, 0, 0, 0, 16, 2, 5, 148, 0, 5, 1, 2, 255, 0, 4, 19, 1, 132, 5]);
        let emm_cause = msg.emm_cause.inner.unwrap();
        assert_eq!(emm_cause, EMMCauseEMMCause::IMSIUnknownInHSS);
        let t_3402 = msg.t_3402.inner.unwrap();
        assert_eq!(t_3402.unit, GPRSTimerUnit::OneMin);
        assert_eq!(t_3402.value, 12);
        let eps_net_feat = msg.eps_net_feat.inner.unwrap();
        assert_eq!(eps_net_feat.cp_c_io_t, 0);
        assert_eq!(eps_net_feat.e_rwo_pdn, 0);
        assert_eq!(eps_net_feat.esr_ps, 0);
        assert_eq!(eps_net_feat.cs_lcs, EPSNetFeatCSLCS::NoInfo);
        assert_eq!(eps_net_feat.epc_lcs, 0);
        assert_eq!(eps_net_feat.emc_bs, 1);
        assert_eq!(eps_net_feat.ims_vo_ps, 1);
    }
}

