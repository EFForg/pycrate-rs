
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EMMAttachRequest {
    pub nas_ksi: Type1V<NASKSI>,
    pub eps_attach_type: Type1V<EPSAttachTypeV>,
    pub epsid: Type4LV<EPSID>,
    #[deku(ctx = "NeedsByteSize")] pub ue_net_cap: Type4LV<UENetCap>,
    #[deku(ctx = "NeedsByteSize")] pub esm_container: Type6LVE<Layer3Buffer>,
    #[deku(bytes = 3, ctx = "Tag(25), NeedsByteSize")] pub old_ptmsi_sign: Type3TV<Layer3Buffer>,
    #[deku(ctx = "Tag(80)")] pub add_guti: Type4TLV<EPSID>,
    #[deku(bytes = 5, ctx = "Tag(82)")] pub old_tai: Type3TV<TAI>,
    #[deku(bytes = 2, ctx = "Tag(92)")] pub drx_param: Type3TV<DRXParam>,
    #[deku(ctx = "Tag(49)")] pub ms_net_cap: Type4TLV<()>,
    #[deku(bytes = 5, ctx = "Tag(19)")] pub old_lai: Type3TV<LAI>,
    #[deku(ctx = "Tag(9)")] pub tmsi_status: Type1TV<TMSIStatus>,
    #[deku(ctx = "Tag(17)")] pub ms_cm_2: Type4TLV<MSCm2>,
    #[deku(ctx = "Tag(32)")] pub ms_cm_3: Type4TLV<()>,
    #[deku(ctx = "Tag(64)")] pub supp_codecs: Type4TLV<()>,
    #[deku(ctx = "Tag(15)")] pub add_update_type: Type1TV<AddUpdateType>,
    #[deku(ctx = "Tag(93)")] pub voice_dom_pref: Type4TLV<VoiceDomPref>,
    #[deku(ctx = "Tag(13)")] pub device_prop: Type1TV<DeviceProp>,
    #[deku(ctx = "Tag(14)")] pub old_guti_type: Type1TV<GUTIType>,
    #[deku(ctx = "Tag(12)")] pub ms_net_feat_supp: Type1TV<MSNetFeatSupp>,
    #[deku(ctx = "Tag(16)")] pub tmsi_based_nri_cont: Type4TLV<NRICont>,
    #[deku(ctx = "Tag(106)")] pub t_3324: Type4TLV<GPRSTimer>,
    #[deku(ctx = "Tag(94)")] pub t_3412_ext: Type4TLV<GPRSTimer3>,
    #[deku(ctx = "Tag(110)")] pub ext_drx_param: Type4TLV<ExtDRXParam>,
    #[deku(ctx = "Tag(111), NeedsByteSize")] pub ue_add_sec_cap: Type4TLV<UEAddSecCap>,
    #[deku(ctx = "Tag(109)")] pub ue_status: Type4TLV<UEStatus>,
    #[deku(bytes = 1, ctx = "Tag(23)")] pub add_info_req: Type3TV<AddInfoReq>,
    #[deku(ctx = "Tag(50), NeedsByteSize")] pub n_1_ue_net_cap: Type4TLV<N1UENetCap>,
    #[deku(ctx = "Tag(11)")] pub ue_radio_cap_id_avail: Type1TV<UERadioCapIDAvail>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NASKSI {
    pub tsc: NASKSITSC,
    pub value: NASKSIValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EPSID {

}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct UENetCap {
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_3: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub ucs_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_3: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub pro_se_dd: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub pro_se: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub h_245_ash: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub acc_csfb: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub lpp: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub lcs: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub x_1_srvcc: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub nf: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub e_pco: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub hc_cp_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub e_rw_o_pdn: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub s_1_u_data: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub up_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub cp_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub pro_se_relay: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub pro_se_dc: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub ft_bearers: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub sgc: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub n_1_mode: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub dcnr: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub cp_back_off: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub restrict_ec: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub v_2_x_pc_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub multi_drb: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub rpr: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub piv: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub ncr: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub v_2_x_nrpc_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub up_mt_edt: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub cp_mt_edt: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub wusa: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub racs: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_3: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub ptcc: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub pr: u8,
    #[deku(count = "byte_size - deku::byte_offset", cond = "deku::byte_offset < byte_size")] pub spare_7: Vec<u8>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct TAI {
    #[deku(count = "3")] pub plmn: Vec<u8>,
    #[deku(bytes = 2, endian = "big")] pub tac: u16,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct DRXParam {
    pub split_pg_cycle_code: DRXParamSPLITPGCYCLECODE,
    pub drx_cycle_len: DRXParamDRXCycleLen,
    #[deku(bits = 1)] pub spli_ton_ccch: u8,
    pub non_drx_timer: DRXParamNonDRXTimer,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct LAI {
    #[deku(count = "3")] pub plmn: Vec<u8>,
    #[deku(bytes = 2, endian = "big")] pub lac: u16,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct TMSIStatus {
    #[deku(bits = 3)] pub spare: u8,
    pub flag: TMSIStatusFlag,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct MSCm2 {
    #[deku(bits = 1)] pub spare_1: u8,
    pub rev_level: MSCm2RevLevel,
    #[deku(bits = 1)] pub early_cm_cap: u8,
    #[deku(bits = 1)] pub no_a_51: u8,
    pub rf_class: MSCm2RFClass,
    #[deku(bits = 1)] pub spare_2: u8,
    #[deku(bits = 1)] pub ps_cap: u8,
    pub ss_screening_cap: MSCm2SSScreeningCap,
    #[deku(bits = 1)] pub mtsms_cap: u8,
    #[deku(bits = 1)] pub vbs_notif_cap: u8,
    #[deku(bits = 1)] pub vgcs_notif_cap: u8,
    #[deku(bits = 1)] pub fc_freq_cap: u8,
    #[deku(bits = 1)] pub ms_cm_3_cap: u8,
    #[deku(bits = 1)] pub spare_3: u8,
    #[deku(bits = 1)] pub lcsva_cap: u8,
    #[deku(bits = 1)] pub ucs_2: u8,
    #[deku(bits = 1)] pub so_lsa_cap: u8,
    #[deku(bits = 1)] pub cm_serv_prompt: u8,
    #[deku(bits = 1)] pub a_53: u8,
    #[deku(bits = 1)] pub a_52: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct AddUpdateType {
    pub pnb_c_io_t: AddUpdateTypePNBCIoT,
    pub saf: AddUpdateTypeSAF,
    pub autv: AddUpdateTypeAUTV,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct VoiceDomPref {
    #[deku(bits = 5)] pub spare: u8,
    pub ue_usage: VoiceDomPrefUEUsage,
    pub voice_dom_pref: VoiceDomPrefVoiceDomPref,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct DeviceProp {
    #[deku(bits = 3)] pub spare: u8,
    #[deku(bits = 1)] pub low_priority: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct GUTIType {
    #[deku(bits = 3)] pub spare: u8,
    pub value: GUTITypeValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct MSNetFeatSupp {
    #[deku(bits = 3)] pub spare: u8,
    #[deku(bits = 1)] pub ext_period_timers: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NRICont {
    #[deku(bits = 10, endian = "big")] pub value: u16,
    #[deku(bits = 6)] pub spare: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct GPRSTimer {
    pub unit: GPRSTimerUnit,
    #[deku(bits = 5)] pub value: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct GPRSTimer3 {
    pub unit: GPRSTimer3Unit,
    #[deku(bits = 5)] pub value: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ExtDRXParam {
    #[deku(bits = 4)] pub ptx: u8,
    #[deku(bits = 4)] pub e_drx: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct UEAddSecCap {
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_8: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_9: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_10: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_11: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_12: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_13: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_14: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_15: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_8: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_9: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_10: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_11: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_12: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_13: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_14: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_15: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct UEStatus {
    #[deku(bits = 6)] pub spare: u8,
    pub n_1_mode_reg: UEStatusN1ModeReg,
    pub s_1_mode_reg: UEStatusS1ModeReg,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct AddInfoReq {
    #[deku(bits = 7)] pub spare: u8,
    pub cipher_key: AddInfoReqCipherKey,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct N1UENetCap {
    #[deku(bits = 2, cond = "deku::byte_offset < byte_size")] pub spare: u8,
    #[deku(bits = 2, cond = "deku::byte_offset < byte_size")] pub five_gs_pnb_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_up_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_hc_cp_c_io_t: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub n_3_data: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_cp_c_io_t: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct UERadioCapIDAvail {
    #[deku(bits = 1)] pub spare: u8,
    pub value: UERadioCapIDAvailValue,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 4)]
pub enum EPSAttachTypeV {
    #[deku(id_pat = "1")] EPSAttach,
    #[deku(id_pat = "2")] CombinedEPSIMSIAttach,
    #[deku(id_pat = "6")] EPSEmergencyAttach,
    #[deku(id_pat = "7")] Reserved,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum UERadioCapIDAvailValue {
    #[deku(id_pat = "0")] UERadioCapabilityIDNotAvailable,
    #[deku(id_pat = "1")] UERadioCapabilityIDAvailable,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum AddInfoReqCipherKey {
    #[deku(id_pat = "0")] CipheringKeysForCipheredBroadcastAssistanceDataNotRequested,
    #[deku(id_pat = "1")] CipheringKeysForCipheredBroadcastAssistanceDataRequested,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum UEStatusN1ModeReg {
    #[deku(id_pat = "0")] UENotIn5GMMREGISTEREDState,
    #[deku(id_pat = "1")] UEIn5GMMREGISTEREDState,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum UEStatusS1ModeReg {
    #[deku(id_pat = "0")] UENotInEMMREGISTEREDState,
    #[deku(id_pat = "1")] UEInEMMREGISTEREDState,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum GPRSTimer3Unit {
    #[deku(id_pat = "0")] TenMin,
    #[deku(id_pat = "1")] OneHour,
    #[deku(id_pat = "2")] TenHours,
    #[deku(id_pat = "3")] TwoSec,
    #[deku(id_pat = "4")] ThirtySec,
    #[deku(id_pat = "5")] OneMin,
    #[deku(id_pat = "6")] ThreeHundredAndTwentyHours,
    #[deku(id_pat = "7")] TimerDeactivated,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum GPRSTimerUnit {
    #[deku(id_pat = "0")] TwoSec,
    #[deku(id_pat = "1")] OneMin,
    #[deku(id_pat = "2")] SixMin,
    #[deku(id_pat = "7")] TimerDeactivated,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum GUTITypeValue {
    #[deku(id_pat = "0")] NativeGUTI,
    #[deku(id_pat = "1")] MappedGUTI,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum VoiceDomPrefUEUsage {
    #[deku(id_pat = "0")] VoiceCentric,
    #[deku(id_pat = "1")] DataCentric,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum VoiceDomPrefVoiceDomPref {
    #[deku(id_pat = "0")] CSVoiceOnly,
    #[deku(id_pat = "1")] IMSPSVoiceOnly,
    #[deku(id_pat = "2")] CSVoicePreferredIMSPSVoiceAsSecondary,
    #[deku(id_pat = "3")] IMSPSVoicePreferredCSVoiceAsSecondary,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum AddUpdateTypePNBCIoT {
    #[deku(id_pat = "0")] NoAdditionalInformation,
    #[deku(id_pat = "1")] ControlPlaneCIoTEPSOptimization,
    #[deku(id_pat = "2")] UserPlaneCIoTEPSOptimization,
    #[deku(id_pat = "3")] Reserved,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum AddUpdateTypeSAF {
    #[deku(id_pat = "0")] NASSignallingNotRequiredAfterCompletionOfTAU,
    #[deku(id_pat = "1")] NASSignallingRequiredAfterCompletionOfTAU,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum AddUpdateTypeAUTV {
    #[deku(id_pat = "1")] SMSOnly,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum MSCm2RevLevel {
    #[deku(id_pat = "0")] ReservedForGSMPhase1,
    #[deku(id_pat = "1")] GSMPhase2MS,
    #[deku(id_pat = "2")] MSSupportingR99OrLater,
    #[deku(id_pat = "3")] FFU,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum MSCm2RFClass {
    #[deku(id_pat = "0")] Class1,
    #[deku(id_pat = "1")] Class2,
    #[deku(id_pat = "2")] Class3,
    #[deku(id_pat = "3")] Class4,
    #[deku(id_pat = "4")] Class5,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum MSCm2SSScreeningCap {
    #[deku(id_pat = "0")] DefaultValueOfPhase1,
    #[deku(id_pat = "1")] CapabilityOfHandlingOfEllipsisNotationAndPhase2ErrorHandling,
    #[deku(id_pat = "2 | 3")] Ffu,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum TMSIStatusFlag {
    #[deku(id_pat = "0")] NoValidTMSIAvailable,
    #[deku(id_pat = "1")] ValidTMSIAvailable,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 8)]
pub enum DRXParamSPLITPGCYCLECODE {
    #[deku(id_pat = "0")] SevenHundredAndFourNoDRX,
    #[deku(id_pat = "65")] SeventyOne,
    #[deku(id_pat = "66")] SeventyTwo,
    #[deku(id_pat = "67")] SeventyFour,
    #[deku(id_pat = "68")] SeventyFive,
    #[deku(id_pat = "69")] SeventySeven,
    #[deku(id_pat = "70")] SeventyNine,
    #[deku(id_pat = "71")] Eighty,
    #[deku(id_pat = "72")] EightyThree,
    #[deku(id_pat = "73")] EightySix,
    #[deku(id_pat = "74")] EightyEight,
    #[deku(id_pat = "75")] Ninety,
    #[deku(id_pat = "76")] NinetyTwo,
    #[deku(id_pat = "77")] NinetySix,
    #[deku(id_pat = "78")] OneHundredAndOne,
    #[deku(id_pat = "79")] OneHundredAndThree,
    #[deku(id_pat = "80")] OneHundredAndSeven,
    #[deku(id_pat = "81")] OneHundredAndTwelve,
    #[deku(id_pat = "82")] OneHundredAndSixteen,
    #[deku(id_pat = "83")] OneHundredAndEighteen,
    #[deku(id_pat = "84")] OneHundredAndTwentyEight,
    #[deku(id_pat = "85")] OneHundredAndFortyOne,
    #[deku(id_pat = "86")] OneHundredAndFortyFour,
    #[deku(id_pat = "87")] OneHundredAndFifty,
    #[deku(id_pat = "88")] OneHundredAndSixty,
    #[deku(id_pat = "89")] OneHundredAndSeventyOne,
    #[deku(id_pat = "90")] OneHundredAndSeventySix,
    #[deku(id_pat = "91")] OneHundredAndNinetyTwo,
    #[deku(id_pat = "92")] TwoHundredAndFourteen,
    #[deku(id_pat = "93")] TwoHundredAndTwentyFour,
    #[deku(id_pat = "94")] TwoHundredAndThirtyFive,
    #[deku(id_pat = "95")] TwoHundredAndFiftySix,
    #[deku(id_pat = "96")] TwoHundredAndEightyEight,
    #[deku(id_pat = "97")] ThreeHundredAndTwenty,
    #[deku(id_pat = "98")] ThreeHundredAndFiftyTwo,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 4)]
pub enum DRXParamDRXCycleLen {
    #[deku(id_pat = "0")] DRXNotSpecifiedByTheMS,
    #[deku(id_pat = "6")] IuCoeff6AndS1T32,
    #[deku(id_pat = "7")] IuCoeff7AndS1T64,
    #[deku(id_pat = "8")] IuCoeff8AndS1T128,
    #[deku(id_pat = "9")] IuCoeff9AndS1T256,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum DRXParamNonDRXTimer {
    #[deku(id_pat = "0")] NoNonDRXModeAfterTransferState,
    #[deku(id_pat = "1")] Max1SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "2")] Max2SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "3")] Max4SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "4")] Max8SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "5")] Max16SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "6")] Max32SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "7")] Max64SecNonDRXModeAfterTransferState,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum NASKSITSC {
    #[deku(id_pat = "0")] NativeSecurityContext,
    #[deku(id_pat = "1")] MappedSecurityContext,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NASKSIValue {
    #[deku(id_pat = "7")] NoKeyAvailable,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("020bf6130184fa6ab2c05ff06205f07000001000360201d031d1272f8080211001000010810600000000830600000000000d00000300ff0003130184000100000c00000a00000500001000521301846a025c0a009011034f18a6f15d0103c1000000000000"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMAttachRequest::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let nas_ksi = msg.nas_ksi.inner;
        assert_eq!(nas_ksi.tsc, NASKSITSC::NativeSecurityContext);
        assert_eq!(nas_ksi.value, NASKSIValue::Other);
        let eps_attach_type = msg.eps_attach_type.inner;
        assert_eq!(eps_attach_type, EPSAttachTypeV::CombinedEPSIMSIAttach);
        let ue_net_cap = msg.ue_net_cap.inner;
        assert_eq!(ue_net_cap.eea_0, 1);
        assert_eq!(ue_net_cap.eea_1_128, 1);
        assert_eq!(ue_net_cap.eea_2_128, 1);
        assert_eq!(ue_net_cap.eea_3_128, 1);
        assert_eq!(ue_net_cap.eea_4, 0);
        assert_eq!(ue_net_cap.eea_5, 0);
        assert_eq!(ue_net_cap.eea_6, 0);
        assert_eq!(ue_net_cap.eea_7, 0);
        assert_eq!(ue_net_cap.eia_0, 0);
        assert_eq!(ue_net_cap.eia_1_128, 1);
        assert_eq!(ue_net_cap.eia_2_128, 1);
        assert_eq!(ue_net_cap.eia_3_128, 1);
        assert_eq!(ue_net_cap.eia_4, 0);
        assert_eq!(ue_net_cap.eia_5, 0);
        assert_eq!(ue_net_cap.eia_6, 0);
        assert_eq!(ue_net_cap.eia_7, 0);
        assert_eq!(ue_net_cap.uea_0, 0);
        assert_eq!(ue_net_cap.uea_1, 0);
        assert_eq!(ue_net_cap.uea_2, 0);
        assert_eq!(ue_net_cap.uea_3, 0);
        assert_eq!(ue_net_cap.uea_4, 0);
        assert_eq!(ue_net_cap.uea_5, 0);
        assert_eq!(ue_net_cap.uea_6, 0);
        assert_eq!(ue_net_cap.uea_7, 0);
        assert_eq!(ue_net_cap.ucs_2, 0);
        assert_eq!(ue_net_cap.uia_1, 0);
        assert_eq!(ue_net_cap.uia_2, 0);
        assert_eq!(ue_net_cap.uia_3, 0);
        assert_eq!(ue_net_cap.uia_4, 0);
        assert_eq!(ue_net_cap.uia_5, 0);
        assert_eq!(ue_net_cap.uia_6, 0);
        assert_eq!(ue_net_cap.uia_7, 0);
        assert_eq!(ue_net_cap.pro_se_dd, 0);
        assert_eq!(ue_net_cap.pro_se, 0);
        assert_eq!(ue_net_cap.h_245_ash, 0);
        assert_eq!(ue_net_cap.acc_csfb, 1);
        assert_eq!(ue_net_cap.lpp, 0);
        assert_eq!(ue_net_cap.lcs, 0);
        assert_eq!(ue_net_cap.x_1_srvcc, 0);
        assert_eq!(ue_net_cap.nf, 0);
        let esm_container = msg.esm_container.inner;
        assert_eq!(esm_container, vec![2, 1, 208, 49, 209, 39, 47, 128, 128, 33, 16, 1, 0, 0, 16, 129, 6, 0, 0, 0, 0, 131, 6, 0, 0, 0, 0, 0, 13, 0, 0, 3, 0, 255, 0, 3, 19, 1, 132, 0, 1, 0, 0, 12, 0, 0, 10, 0, 0, 5, 0, 0, 16, 0]);
        let old_tai = msg.old_tai.inner.unwrap();
        assert_eq!(old_tai.plmn, vec![19, 1, 132]);
        assert_eq!(old_tai.tac, 27138);
        let drx_param = msg.drx_param.inner.unwrap();
        assert_eq!(drx_param.split_pg_cycle_code, DRXParamSPLITPGCYCLECODE::Other);
        assert_eq!(drx_param.drx_cycle_len, DRXParamDRXCycleLen::DRXNotSpecifiedByTheMS);
        assert_eq!(drx_param.spli_ton_ccch, 0);
        assert_eq!(drx_param.non_drx_timer, DRXParamNonDRXTimer::NoNonDRXModeAfterTransferState);
        let tmsi_status = msg.tmsi_status.inner.unwrap();
        assert_eq!(tmsi_status.flag, TMSIStatusFlag::NoValidTMSIAvailable);
        let ms_cm_2 = msg.ms_cm_2.inner.unwrap();
        assert_eq!(ms_cm_2.rev_level, MSCm2RevLevel::MSSupportingR99OrLater);
        assert_eq!(ms_cm_2.early_cm_cap, 0);
        assert_eq!(ms_cm_2.no_a_51, 1);
        assert_eq!(ms_cm_2.rf_class, MSCm2RFClass::Other);
        assert_eq!(ms_cm_2.ps_cap, 0);
        assert_eq!(ms_cm_2.ss_screening_cap, MSCm2SSScreeningCap::CapabilityOfHandlingOfEllipsisNotationAndPhase2ErrorHandling);
        assert_eq!(ms_cm_2.mtsms_cap, 1);
        assert_eq!(ms_cm_2.vbs_notif_cap, 0);
        assert_eq!(ms_cm_2.vgcs_notif_cap, 0);
        assert_eq!(ms_cm_2.fc_freq_cap, 0);
        assert_eq!(ms_cm_2.ms_cm_3_cap, 1);
        assert_eq!(ms_cm_2.lcsva_cap, 1);
        assert_eq!(ms_cm_2.ucs_2, 0);
        assert_eq!(ms_cm_2.so_lsa_cap, 0);
        assert_eq!(ms_cm_2.cm_serv_prompt, 1);
        assert_eq!(ms_cm_2.a_53, 1);
        assert_eq!(ms_cm_2.a_52, 0);
        let add_update_type = msg.add_update_type.inner.unwrap();
        assert_eq!(add_update_type.pnb_c_io_t, AddUpdateTypePNBCIoT::NoAdditionalInformation);
        assert_eq!(add_update_type.saf, AddUpdateTypeSAF::NASSignallingNotRequiredAfterCompletionOfTAU);
        assert_eq!(add_update_type.autv, AddUpdateTypeAUTV::SMSOnly);
        let voice_dom_pref = msg.voice_dom_pref.inner.unwrap();
        assert_eq!(voice_dom_pref.ue_usage, VoiceDomPrefUEUsage::VoiceCentric);
        assert_eq!(voice_dom_pref.voice_dom_pref, VoiceDomPrefVoiceDomPref::IMSPSVoicePreferredCSVoiceAsSecondary);
        let ms_net_feat_supp = msg.ms_net_feat_supp.inner.unwrap();
        assert_eq!(ms_net_feat_supp.ext_period_timers, 1);
    }
}

