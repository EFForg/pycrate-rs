
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EMMAuthenticationRequest {
    #[deku(pad_bits_before = "4")] pub nas_ksi: Type1V<NASKSI>,
    #[deku(bytes = 16, ctx = "NeedsByteSize")] pub rand: Type3V<Layer3Buffer>,
    pub autn: Type4LV<AUTN>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NASKSI {
    pub tsc: NASKSITSC,
    pub value: NASKSIValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct AUTN {
    #[deku(count = "6")] pub sq_nx_ak: Vec<u8>,
    #[deku(count = "2")] pub amf: Vec<u8>,
    #[deku(count = "8")] pub mac: Vec<u8>,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum NASKSITSC {
    #[deku(id_pat = "0")] NativeSecurityContext,
    #[deku(id_pat = "1")] MappedSecurityContext,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NASKSIValue {
    #[deku(id_pat = "7")] NoKeyAvailable,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("0035040951a94d3d9487a31d5d7dd58b17108709d118a5238001b73bffabc570d08d"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMAuthenticationRequest::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let nas_ksi = msg.nas_ksi.inner;
        assert_eq!(nas_ksi.tsc, NASKSITSC::NativeSecurityContext);
        assert_eq!(nas_ksi.value, NASKSIValue::Other);
        let rand = msg.rand.inner;
        assert_eq!(rand, vec![53, 4, 9, 81, 169, 77, 61, 148, 135, 163, 29, 93, 125, 213, 139, 23]);
        let autn = msg.autn.inner;
        assert_eq!(autn.sq_nx_ak, vec![135, 9, 209, 24, 165, 35]);
        assert_eq!(autn.amf, vec![128, 1]);
        assert_eq!(autn.mac, vec![183, 59, 255, 171, 197, 112, 208, 141]);
    }
}

