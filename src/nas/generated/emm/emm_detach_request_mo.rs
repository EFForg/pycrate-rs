
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EMMDetachRequestMO {
    pub nas_ksi: Type1V<NASKSI>,
    pub eps_detach_type: Type1V<EPSDetachTypeMO>,
    pub epsid: Type4LV<EPSID>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NASKSI {
    pub tsc: NASKSITSC,
    pub value: NASKSIValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EPSDetachTypeMO {
    #[deku(bits = 1)] pub switch_off: u8,
    pub typ: EPSDetachTypeMOType,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EPSID {

}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum EPSDetachTypeMOType {
    #[deku(id_pat = "0 | 3 | 4 | 5")] CombinedEPSIMSIDetach,
    #[deku(id_pat = "1")] EPSDetach,
    #[deku(id_pat = "2")] IMSIDetach,
    #[deku(id_pat = "6 | 7")] Reserved,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum NASKSITSC {
    #[deku(id_pat = "0")] NativeSecurityContext,
    #[deku(id_pat = "1")] MappedSecurityContext,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NASKSIValue {
    #[deku(id_pat = "7")] NoKeyAvailable,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("630bf602f8108003c8c2e65e9a"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMDetachRequestMO::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let nas_ksi = msg.nas_ksi.inner;
        assert_eq!(nas_ksi.tsc, NASKSITSC::NativeSecurityContext);
        assert_eq!(nas_ksi.value, NASKSIValue::Other);
        let eps_detach_type = msg.eps_detach_type.inner;
        assert_eq!(eps_detach_type.switch_off, 0);
        assert_eq!(eps_detach_type.typ, EPSDetachTypeMOType::CombinedEPSIMSIDetach);
    }

    #[test]
    fn test_case_2() {
        let mut bytes = Cursor::new(unhexlify("290bf6130184fa6aaec192a663000000000000"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMDetachRequestMO::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let nas_ksi = msg.nas_ksi.inner;
        assert_eq!(nas_ksi.tsc, NASKSITSC::NativeSecurityContext);
        assert_eq!(nas_ksi.value, NASKSIValue::Other);
        let eps_detach_type = msg.eps_detach_type.inner;
        assert_eq!(eps_detach_type.switch_off, 1);
        assert_eq!(eps_detach_type.typ, EPSDetachTypeMOType::EPSDetach);
    }
}

