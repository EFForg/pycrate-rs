
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EMMInformation {
    #[deku(ctx = "Tag(67), NeedsByteSize")] pub net_full_name: Type4TLV<NetworkName>,
    #[deku(ctx = "Tag(69), NeedsByteSize")] pub net_short_name: Type4TLV<NetworkName>,
    #[deku(bytes = 1, ctx = "Tag(70)")] pub local_time_zone: Type3TV<TimeZone>,
    #[deku(bytes = 7, ctx = "Tag(71)")] pub univ_time_and_time_zone: Type3TV<TimeZoneTime>,
    #[deku(ctx = "Tag(73)")] pub dl_saving_time: Type4TLV<DLSavingTime>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct NetworkName {
    #[deku(bits = 1)] pub ext: u8,
    pub coding: NetworkNameCoding,
    #[deku(bits = 1)] pub add_country_initials: u8,
    #[deku(bits = 3)] pub spare_bits: u8,
    #[deku(count = "byte_size - deku::byte_offset")] pub name: Vec<u8>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct TimeZone {
    #[deku(bits = 4)] pub tz_1: u8,
    pub tzs: TimeZoneTZS,
    #[deku(bits = 3)] pub tz_0: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct TimeZoneTime {
    pub year: Year,
    pub mon: Mon,
    pub day: Day,
    pub hour: Hour,
    pub min: Min,
    pub sec: Sec,
    pub time_zone: TimeZone,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct DLSavingTime {
    #[deku(bits = 6)] pub spare: u8,
    pub value: DLSavingTimeValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Year {
    #[deku(bits = 4)] pub y_1: u8,
    #[deku(bits = 4)] pub y_0: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Mon {
    #[deku(bits = 4)] pub m_1: u8,
    #[deku(bits = 4)] pub m_0: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Day {
    #[deku(bits = 4)] pub d_1: u8,
    #[deku(bits = 4)] pub d_0: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Hour {
    #[deku(bits = 4)] pub h_1: u8,
    #[deku(bits = 4)] pub h_0: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Min {
    #[deku(bits = 4)] pub m_1: u8,
    #[deku(bits = 4)] pub m_0: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct Sec {
    #[deku(bits = 4)] pub s_1: u8,
    #[deku(bits = 4)] pub s_0: u8,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 2)]
pub enum DLSavingTimeValue {
    #[deku(id_pat = "0")] NoAdjustmentForDaylightSavingTime,
    #[deku(id_pat = "1")] Plus1HourAdjustmentForDaylightSavingTime,
    #[deku(id_pat = "2")] Plus2HoursAdjustmentForDaylightSavingTime,
    #[deku(id_pat = "3")] Reserved,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum TimeZoneTZS {
    #[deku(id_pat = "0")] Plus,
    #[deku(id_pat = "1")] Minus,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NetworkNameCoding {
    #[deku(id_pat = "0")] GSM7BitDefaultAlphabet,
    #[deku(id_pat = "1")] UCS216Bit,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("430f80d6b23cad7fbb41d7b4bccc2ecfe745048356ed15462b474210013213322b490100"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMInformation::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let net_full_name = msg.net_full_name.inner.unwrap();
        assert_eq!(net_full_name.ext, 1);
        assert_eq!(net_full_name.coding, NetworkNameCoding::GSM7BitDefaultAlphabet);
        assert_eq!(net_full_name.add_country_initials, 0);
        assert_eq!(net_full_name.name, vec![214, 178, 60, 173, 127, 187, 65, 215, 180, 188, 204, 46, 207, 231]);
        let net_short_name = msg.net_short_name.inner.unwrap();
        assert_eq!(net_short_name.ext, 1);
        assert_eq!(net_short_name.coding, NetworkNameCoding::GSM7BitDefaultAlphabet);
        assert_eq!(net_short_name.add_country_initials, 0);
        assert_eq!(net_short_name.name, vec![86, 237, 21]);
        let local_time_zone = msg.local_time_zone.inner.unwrap();
        assert_eq!(local_time_zone.tz_1, 2);
        assert_eq!(local_time_zone.tzs, TimeZoneTZS::Minus);
        assert_eq!(local_time_zone.tz_0, 3);
        let univ_time_and_time_zone = msg.univ_time_and_time_zone.inner.unwrap();
        assert_eq!(univ_time_and_time_zone.year.y_1, 4);
        assert_eq!(univ_time_and_time_zone.year.y_0, 2);
        assert_eq!(univ_time_and_time_zone.mon.m_1, 1);
        assert_eq!(univ_time_and_time_zone.mon.m_0, 0);
        assert_eq!(univ_time_and_time_zone.day.d_1, 0);
        assert_eq!(univ_time_and_time_zone.day.d_0, 1);
        assert_eq!(univ_time_and_time_zone.hour.h_1, 3);
        assert_eq!(univ_time_and_time_zone.hour.h_0, 2);
        assert_eq!(univ_time_and_time_zone.min.m_1, 1);
        assert_eq!(univ_time_and_time_zone.min.m_0, 3);
        assert_eq!(univ_time_and_time_zone.sec.s_1, 3);
        assert_eq!(univ_time_and_time_zone.sec.s_0, 2);
        assert_eq!(univ_time_and_time_zone.time_zone.tz_1, 2);
        assert_eq!(univ_time_and_time_zone.time_zone.tzs, TimeZoneTZS::Minus);
        assert_eq!(univ_time_and_time_zone.time_zone.tz_0, 3);
        let dl_saving_time = msg.dl_saving_time.inner.unwrap();
        assert_eq!(dl_saving_time.value, DLSavingTimeValue::NoAdjustmentForDaylightSavingTime);
    }
}

