
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct EMMSecurityModeCommand {
    #[deku(bytes = 1)] pub nas_sec_algo: Type3V<NASSecAlgo>,
    #[deku(pad_bits_before = "4")] pub nas_ksi: Type1V<NASKSI>,
    #[deku(ctx = "NeedsByteSize")] pub ue_sec_cap: Type4LV<UESecCap>,
    #[deku(ctx = "Tag(12)")] pub imeisv_req: Type1TV<IMEISVReq>,
    #[deku(bytes = 4, ctx = "Tag(85), NeedsByteSize")] pub nonce_ue: Type3TV<Layer3Buffer>,
    #[deku(bytes = 4, ctx = "Tag(86), NeedsByteSize")] pub nonce_mme: Type3TV<Layer3Buffer>,
    #[deku(ctx = "Tag(79), NeedsByteSize")] pub hash_mme: Type4TLV<Layer3Buffer>,
    #[deku(ctx = "Tag(111), NeedsByteSize")] pub ue_add_sec_cap: Type4TLV<UEAddSecCap>,
    #[deku(ctx = "Tag(13)")] pub ue_radio_cap_id_req: Type1TV<UERadioCapIDReq>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NASSecAlgo {
    #[deku(bits = 1)] pub spare_1: u8,
    pub ciph_algo: NASSecAlgoCiphAlgo,
    #[deku(bits = 1)] pub spare_2: u8,
    pub integ_algo: NASSecAlgoIntegAlgo,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct NASKSI {
    pub tsc: NASKSITSC,
    pub value: NASKSIValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct UESecCap {
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eea_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub eia_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_3: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uea_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_3: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub uia_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub spare_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_1: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_2: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_3: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub gea_7: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct IMEISVReq {
    #[deku(bits = 1)] pub spare: u8,
    pub value: IMEISVReqValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct UEAddSecCap {
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_8: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_9: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_10: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_11: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_12: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_13: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_14: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ea_15: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_0: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_1_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_2_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_3_128: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_4: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_5: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_6: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_7: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_8: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_9: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_10: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_11: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_12: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_13: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_14: u8,
    #[deku(bits = 1, cond = "deku::byte_offset < byte_size")] pub five_g_ia_15: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct UERadioCapIDReq {
    #[deku(bits = 1)] pub spare: u8,
    pub value: UERadioCapIDReqValue,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum UERadioCapIDReqValue {
    #[deku(id_pat = "0")] UERadioCapabilityIDNotRequested,
    #[deku(id_pat = "1")] UERadioCapabilityIDRequested,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum IMEISVReqValue {
    #[deku(id_pat = "0")] IMEISVNotRequested,
    #[deku(id_pat = "1")] IMEISVRequested,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum NASKSITSC {
    #[deku(id_pat = "0")] NativeSecurityContext,
    #[deku(id_pat = "1")] MappedSecurityContext,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NASKSIValue {
    #[deku(id_pat = "7")] NoKeyAvailable,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NASSecAlgoCiphAlgo {
    #[deku(id_pat = "0")] EPSEncryptionAlgorithmEEA0Null,
    #[deku(id_pat = "1")] EPSEncryptionAlgorithm128EEA1SNOW,
    #[deku(id_pat = "2")] EPSEncryptionAlgorithm128EEA2AES,
    #[deku(id_pat = "3")] EPSEncryptionAlgorithm128EEA3ZUC,
    #[deku(id_pat = "4")] EPSEncryptionAlgorithmEEA4,
    #[deku(id_pat = "5")] EPSEncryptionAlgorithmEEA5,
    #[deku(id_pat = "6")] EPSEncryptionAlgorithmEEA6,
    #[deku(id_pat = "7")] EPSEncryptionAlgorithmEEA7,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum NASSecAlgoIntegAlgo {
    #[deku(id_pat = "0")] EPSIntegrityAlgorithmEIA0Null,
    #[deku(id_pat = "1")] EPSIntegrityAlgorithm128EIA1SNOW,
    #[deku(id_pat = "2")] EPSIntegrityAlgorithm128EIA2AES,
    #[deku(id_pat = "3")] EPSIntegrityAlgorithm128EIA3ZUC,
    #[deku(id_pat = "4")] EPSIntegrityAlgorithmEIA4,
    #[deku(id_pat = "5")] EPSIntegrityAlgorithmEIA5,
    #[deku(id_pat = "6")] EPSIntegrityAlgorithmEIA6,
    #[deku(id_pat = "7")] EPSIntegrityAlgorithmEIA7,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("330002f070c1"));
        let mut reader = Reader::new(&mut bytes);
        let msg = EMMSecurityModeCommand::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let nas_sec_algo = msg.nas_sec_algo.inner;
        assert_eq!(nas_sec_algo.ciph_algo, NASSecAlgoCiphAlgo::EPSEncryptionAlgorithm128EEA3ZUC);
        assert_eq!(nas_sec_algo.integ_algo, NASSecAlgoIntegAlgo::EPSIntegrityAlgorithm128EIA3ZUC);
        let nas_ksi = msg.nas_ksi.inner;
        assert_eq!(nas_ksi.tsc, NASKSITSC::NativeSecurityContext);
        assert_eq!(nas_ksi.value, NASKSIValue::Other);
        let ue_sec_cap = msg.ue_sec_cap.inner;
        assert_eq!(ue_sec_cap.eea_0, 1);
        assert_eq!(ue_sec_cap.eea_1_128, 1);
        assert_eq!(ue_sec_cap.eea_2_128, 1);
        assert_eq!(ue_sec_cap.eea_3_128, 1);
        assert_eq!(ue_sec_cap.eea_4, 0);
        assert_eq!(ue_sec_cap.eea_5, 0);
        assert_eq!(ue_sec_cap.eea_6, 0);
        assert_eq!(ue_sec_cap.eea_7, 0);
        assert_eq!(ue_sec_cap.eia_0, 0);
        assert_eq!(ue_sec_cap.eia_1_128, 1);
        assert_eq!(ue_sec_cap.eia_2_128, 1);
        assert_eq!(ue_sec_cap.eia_3_128, 1);
        assert_eq!(ue_sec_cap.eia_4, 0);
        assert_eq!(ue_sec_cap.eia_5, 0);
        assert_eq!(ue_sec_cap.eia_6, 0);
        assert_eq!(ue_sec_cap.eia_7, 0);
        let imeisv_req = msg.imeisv_req.inner.unwrap();
        assert_eq!(imeisv_req.value, IMEISVReqValue::IMEISVRequested);
    }
}

