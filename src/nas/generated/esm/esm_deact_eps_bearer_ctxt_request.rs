
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ESMDeactEPSBearerCtxtRequest {
    #[deku(bytes = 1)] pub esm_cause: Type3V<ESMCauseESMCause>,
    #[deku(ctx = "Tag(39)")] pub prot_config: Type4TLV<ProtConfig>,
    #[deku(ctx = "Tag(55)")] pub back_off_timer: Type4TLV<GPRSTimer3>,
    #[deku(ctx = "Tag(12)")] pub wlan_offload_ind: Type1TV<WLANOffloadAccept>,
    #[deku(ctx = "Tag(51)")] pub nbifom_container: Type4TLV<()>,
    #[deku(ctx = "Tag(123)")] pub ext_prot_config: Type6TLVE<ProtConfig>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ProtConfig {
    #[deku(bits = 1)] pub ext: u8,
    #[deku(bits = 4)] pub spare: u8,
    pub prot: ProtConfigProt,
    pub config: (),
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct GPRSTimer3 {
    pub unit: GPRSTimer3Unit,
    #[deku(bits = 5)] pub value: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct WLANOffloadAccept {
    #[deku(bits = 2)] pub spare: u8,
    pub utran_offload_accept: WLANOffloadAcceptUTRANOffloadAccept,
    pub eutran_offload_accept: WLANOffloadAcceptEUTRANOffloadAccept,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 8)]
pub enum ESMCauseESMCause {
    #[deku(id_pat = "8")] OperatorDeterminedBarring,
    #[deku(id_pat = "26")] InsufficientResources,
    #[deku(id_pat = "27")] MissingOrUnknownAPN,
    #[deku(id_pat = "28")] UnknownPDNType,
    #[deku(id_pat = "29")] UserAuthenticationFailed,
    #[deku(id_pat = "30")] RequestRejectedByServingGWOrPDNGW,
    #[deku(id_pat = "31")] RequestRejectedUnspecified,
    #[deku(id_pat = "32")] ServiceOptionNotSupported,
    #[deku(id_pat = "33")] RequestedServiceOptionNotSubscribed,
    #[deku(id_pat = "34")] ServiceOptionTemporarilyOutOfOrder,
    #[deku(id_pat = "35")] PTIAlreadyInUse,
    #[deku(id_pat = "36")] RegularDeactivation,
    #[deku(id_pat = "37")] EPSQoSNotAccepted,
    #[deku(id_pat = "38")] NetworkFailure,
    #[deku(id_pat = "39")] ReactivationRequested,
    #[deku(id_pat = "41")] SemanticErrorInTheTFTOperation,
    #[deku(id_pat = "42")] SyntacticalErrorInTheTFTOperation,
    #[deku(id_pat = "43")] InvalidEPSBearerIdentity,
    #[deku(id_pat = "44")] SemanticErrorsInPacketFilterS,
    #[deku(id_pat = "45")] SyntacticalErrorsInPacketFilterS,
    #[deku(id_pat = "46")] UnusedSeeNOTE2,
    #[deku(id_pat = "47")] PTIMismatch,
    #[deku(id_pat = "49")] LastPDNDisconnectionNotAllowed,
    #[deku(id_pat = "50")] PDNTypeIPv4OnlyAllowed,
    #[deku(id_pat = "51")] PDNTypeIPv6OnlyAllowed,
    #[deku(id_pat = "52")] SingleAddressBearersOnlyAllowed,
    #[deku(id_pat = "53")] ESMInformationNotReceived,
    #[deku(id_pat = "54")] PDNConnectionDoesNotExist,
    #[deku(id_pat = "55")] MultiplePDNConnectionsForAGivenAPNNotAllowed,
    #[deku(id_pat = "56")] CollisionWithNetworkInitiatedRequest,
    #[deku(id_pat = "59")] UnsupportedQCIValue,
    #[deku(id_pat = "60")] BearerHandlingNotSupported,
    #[deku(id_pat = "65")] MaximumNumberOfEPSBearersReached,
    #[deku(id_pat = "66")] RequestedAPNNotSupportedInCurrentRATAndPLMNCombination,
    #[deku(id_pat = "81")] InvalidPTIValue,
    #[deku(id_pat = "95")] SemanticallyIncorrectMessage,
    #[deku(id_pat = "96")] InvalidMandatoryInformation,
    #[deku(id_pat = "97")] MessageTypeNonExistentOrNotImplemented,
    #[deku(id_pat = "98")] MessageTypeNotCompatibleWithTheProtocolState,
    #[deku(id_pat = "99")] InformationElementNonExistentOrNotImplemented,
    #[deku(id_pat = "100")] ConditionalIEError,
    #[deku(id_pat = "101")] MessageNotCompatibleWithTheProtocolState,
    #[deku(id_pat = "111")] ProtocolErrorUnspecified,
    #[deku(id_pat = "112")] APNRestrictionValueIncompatibleWithActiveEPSBearerContext,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum WLANOffloadAcceptUTRANOffloadAccept {
    #[deku(id_pat = "0")] OffloadingTheTrafficOfThePDNConnectionViaAWLANWhenInIuModeIsNotAcceptable,
    #[deku(id_pat = "1")] OffloadingTheTrafficOfThePDNConnectionViaAWLANWhenInIuModeIsAcceptable,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum WLANOffloadAcceptEUTRANOffloadAccept {
    #[deku(id_pat = "0")] OffloadingTheTrafficOfThePDNConnectionViaAWLANWhenInS1ModeIsNotAcceptable,
    #[deku(id_pat = "1")] OffloadingTheTrafficOfThePDNConnectionViaAWLANWhenInS1ModeIsAcceptable,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum GPRSTimer3Unit {
    #[deku(id_pat = "0")] TenMin,
    #[deku(id_pat = "1")] OneHour,
    #[deku(id_pat = "2")] TenHours,
    #[deku(id_pat = "3")] TwoSec,
    #[deku(id_pat = "4")] ThirtySec,
    #[deku(id_pat = "5")] OneMin,
    #[deku(id_pat = "6")] ThreeHundredAndTwentyHours,
    #[deku(id_pat = "7")] TimerDeactivated,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum ProtConfigProt {
    #[deku(id_pat = "0")] PPPWithIPPDP,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("24"));
        let mut reader = Reader::new(&mut bytes);
        let msg = ESMDeactEPSBearerCtxtRequest::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let esm_cause = msg.esm_cause.inner;
        assert_eq!(esm_cause, ESMCauseESMCause::RegularDeactivation);
    }
}

