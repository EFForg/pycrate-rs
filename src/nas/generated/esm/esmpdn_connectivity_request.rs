
use deku::prelude::*;
use deku::ctx::ByteSize;
use serde::Serialize;
use crate::nas::layer3::*;

/// Autogenerated rust code, do not modify directly! Any changes should be
/// made via the python generator scripts.

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ESMPDNConnectivityRequest {
    pub pdn_type: Type1V<PDNTypeV>,
    pub request_type: Type1V<RequestTypeV>,
    #[deku(ctx = "Tag(13)")] pub esm_info_transfer_flag: Type1TV<ESMInfoTransferFlag>,
    #[deku(ctx = "Tag(40)")] pub apn: Type4TLV<()>,
    #[deku(ctx = "Tag(39)")] pub prot_config: Type4TLV<ProtConfig>,
    #[deku(ctx = "Tag(12)")] pub device_prop: Type1TV<DeviceProp>,
    #[deku(ctx = "Tag(51)")] pub nbifom_container: Type4TLV<()>,
    #[deku(ctx = "Tag(102), NeedsByteSize")] pub hdr_comp_config: Type4TLV<HdrCompConfig>,
    #[deku(ctx = "Tag(123)")] pub ext_prot_config: Type6TLVE<ProtConfig>,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ESMInfoTransferFlag {
    #[deku(bits = 3)] pub spare: u8,
    pub value: ESMInfoTransferFlagValue,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct ProtConfig {
    #[deku(bits = 1)] pub ext: u8,
    #[deku(bits = 4)] pub spare: u8,
    pub prot: ProtConfigProt,
    pub config: (),
}

#[derive(DekuRead, Debug, Serialize, Clone)]
pub struct DeviceProp {
    #[deku(bits = 3)] pub spare: u8,
    #[deku(bits = 1)] pub low_priority: u8,
}

#[derive(DekuRead, Debug, Serialize, Clone)]
#[deku(ctx = "ByteSize(byte_size): ByteSize")]
pub struct HdrCompConfig {
    #[deku(bits = 1)] pub spare: u8,
    #[deku(bits = 1)] pub p_0x0104: u8,
    #[deku(bits = 1)] pub p_0x0103: u8,
    #[deku(bits = 1)] pub p_0x0102: u8,
    #[deku(bits = 1)] pub p_0x0006: u8,
    #[deku(bits = 1)] pub p_0x0004: u8,
    #[deku(bits = 1)] pub p_0x0003: u8,
    #[deku(bits = 1)] pub p_0x0002: u8,
    #[deku(bytes = 2, endian = "big")] pub max_cid: u16,
    pub params_type: HdrCompConfigParamsType,
    #[deku(count = "byte_size - deku::byte_offset")] pub params_container: Vec<u8>,
}
#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 4)]
pub enum PDNTypeV {
    #[deku(id_pat = "1")] IPv4,
    #[deku(id_pat = "2")] IPv6,
    #[deku(id_pat = "3")] IPv4V6,
    #[deku(id_pat = "4")] NonIP,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 4)]
pub enum RequestTypeV {
    #[deku(id_pat = "1")] InitialRequest,
    #[deku(id_pat = "2")] Handover,
    #[deku(id_pat = "3")] UnusedInterpretedAsInitialRequest,
    #[deku(id_pat = "4")] Emergency,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 0)]
pub enum HdrCompConfigParamsType {
    #[deku(id_pat = "0")] ZeroNoCompression,
    #[deku(id_pat = "1")] TwoUDPIP,
    #[deku(id_pat = "2")] ThreeESPIP,
    #[deku(id_pat = "3")] FourIP,
    #[deku(id_pat = "4")] SixTCPIP,
    #[deku(id_pat = "5")] OneHundredAndTwoUDPIP,
    #[deku(id_pat = "6")] OneHundredAndThreeESPIP,
    #[deku(id_pat = "7")] OneHundredAndFourIP,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 3)]
pub enum ProtConfigProt {
    #[deku(id_pat = "0")] PPPWithIPPDP,
    #[deku(id_pat = "_")] Other,
}

#[derive(DekuRead, Debug, Serialize, Clone, PartialEq)]
#[deku(id_type = "u8", bits = 1)]
pub enum ESMInfoTransferFlagValue {
    #[deku(id_pat = "0")] SecurityProtectedESMInformationTransferNotRequired,
    #[deku(id_pat = "1")] SecurityProtectedESMInformationTransferRequired,
    #[deku(id_pat = "_")] Other,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nas::test_utils::*;
    use deku::prelude::*;
    use std::io::Cursor;

    #[test]
    fn test_case_1() {
        let mut bytes = Cursor::new(unhexlify("31280c0b565a57494e5445524e455427298080211001000010810600000000830600000000000d00000300ff0003130184000a00000500001000000000000000"));
        let mut reader = Reader::new(&mut bytes);
        let msg = ESMPDNConnectivityRequest::from_reader_with_ctx(&mut reader, ())
            .expect("failed to parse");
        let pdn_type = msg.pdn_type.inner;
        assert_eq!(pdn_type, PDNTypeV::IPv4V6);
        let request_type = msg.request_type.inner;
        assert_eq!(request_type, RequestTypeV::InitialRequest);
        let prot_config = msg.prot_config.inner.unwrap();
        assert_eq!(prot_config.ext, 1);
        assert_eq!(prot_config.prot, ProtConfigProt::PPPWithIPPDP);
    }
}

